#!/bin/bash
#
#    bl-obthemes: script graphique pour Sauvegarder ou Restaurer des configurations openbox
#    Copyright (C) 2015 damo    <damo@bunsenlabs.org>
#    Traduis par Luvalem
#
#    Ce programme est un logiciel libre: vous pouvez le redistribuer
#    et / ou le modifier selon les termes de la Licence Publique 
#    Générale GNU publiée par la Free Software Foundation,
#    soit la version 3 de la licence, soit (à votre choix)
#    toute version ultérieure.
#
#    Ce programme est distribué dans l'espoir qu'il sera utile,
#    Mais SANS AUCUNE GARANTIE; Sans même la garantie implicite de
#    QUALITÉ MARCHANDE OU ADAPTATION À UN USAGE PARTICULIER.  Voir la
#    GNU General Public License pour plus de détails.
#
#   Vous devriez avoir reçu une copie de la Licence Publique 
#   Générale GNUavec ce programme.  Sinon, voir 
#   <http://www.gnu.org/licenses/>.
#
#
# Options de Sauvegarde pour  Conky(s)
#                             Tint2(s)
#                             Openbox theme
#                             GTK theme
#                             Background (uses Nitrogen or feh, depending which
#                                   has the newer saved bg config file)
#                             Alt Menu (dmenu)
#                             Lightdm login gtk greeter
#                             Exit dialog theme
#                             X configs (.bashrc, .Xresources)
#                             Terminator config
#                             Exit dialogue
#
# Les chemins sont supposés être des valeurs par défaut de BunsenLabs
#
# Une capture d'écran est enregistrée (la fenetre est cachée brievement 
#                                      donc l'image du bureau est nue, 
#                                      avec chaques Tint2s ou Conkys Actifs
#                                      et un menu représentatif)
#
# Une sauvegarde horodatée de rc.xml Est enregistré "juste au cas où".
#
# USER VARIABLE: Xdotool est utilisé pour déplacer le pointeur de la souris, 
# le root-menu est affiché avec les touches "Super + Space", et le bouton droit de la souris est
# fixé pour "r-click". Si vous les avez réglés à autre chose, alors éditez les variables
# "MENUMODIFIER" and "MOUSECMD".
# Définir la variable "KEYDOWN" jusqu'où "Preferences" est dans le menu root (ou
# tout autre chose que vous pourriez vouloir afficher).
# Le visionneur d'image est réglé sur "bl-image-viewer". Editer la variable "IMGCMD"
# pour le changer.
#
# Attention: Il est supposé que les conkys ne sont pas exécutés via un script,
# donc ils apparaîtront sur tous les ordinateurs de bureau.Si vous utilisez 
# habituellement un script, alors vous devrez peut-être faire vos propres 
# arrangements! Conkys dans les répertoires non-par défaut peuvent être enregistrés,
# mais ne seront pas vus lors de l'exécution du sélecteur bl-conky
########################################################################
#
# PROBLÈMES CONNUS:
# Virtualbox ne permet pas à l'invité de déplacer le curseur de la souris hôte,
# en utilisant xdotool, de sorte que la capture d'écran peut produire un thème 
# incorrect affiché et / ou mauvais positionnement.Une solution de contournement 
# consiste à déplacer le curseur sur un espace libre et à utiliser la touche
# "Entrée" dans la boîte de dialogue "Configurations à enregistrer:".
#

HELP='bl-obthemes script graphique pour Sauvegarder ou Restaurer des 
configurations openbox

Options:
    -h --help   Affiche ce message

Pas d`autre options.

 Options de Sauvegarde pour  Conky(s)
                             Tint2(s)
                             Openbox theme
                             GTK theme
                             Background (utilise Nitrogen ou feh, suivant
                                         configuration )
                             Alt Menu (dmenu)
                             Lightdm login gtk greeter
                             Exit dialog theme
                             X configs (.bashrc, .Xresources)
                             Terminator config
                             Exit dialogue

 Les chemins sont supposés être des valeurs par défaut de BunsenLabs.

 Une capture d`écran est enregistrée (la fenetre est cachée brievement 
                                      donc limage du bureau est nue, 
                                      avec chaques Tint2s ou Conkys Actifs
                                      et un menu représentatif)

 Une sauvegarde horodatée de rc.xml Est enregistré "juste au cas où".

Configuration:

 USER VARIABLE: Xdotool est utilisé pour déplacer le pointeur de la souris, 
 le root-menu est affiché avec les touches "Super + Space", et le bouton
 droit de la souris est fixé pour "r-click". Si vous les avez réglés à 
 autre chose, alors éditez les variables "MENUMODIFIER" and "MOUSECMD".
 Définir la variable "KEYDOWN" jusqu`où "Preferences" est dans le menu root (ou
 tout autre chose que vous pourriez vouloir afficher).
 Le visionneur d`image est réglé sur "bl-image-viewer". Editer la variable "IMGCMD"
 pour le changer.

 Attention: Il est supposé que les conkys ne sont pas exécutés via un script,
 donc ils apparaîtront sur tous les ordinateurs de bureau.Si vous utilisez 
 habituellement un script, alors vous devrez peut-être faire vos propres 
 arrangements! Conkys dans les répertoires non-par défaut peuvent être enregistrés,
 mais ne seront pas vus lors de l`exécution du sélecteur bl-conky
########################################################################

 PROBLÈMES CONNUS:
 Virtualbox ne permet pas à l`invité de déplacer le curseur de la souris hôte,
 en utilisant xdotool, de sorte que la capture d`écran peut produire un thème 
 incorrect affiché et / ou mauvais positionnement.Une solution de contournement 
 consiste à déplacer le curseur sur un espace libre et à utiliser la touche
 "Entrée" dans la boîte de dialogue "Configurations à enregistrer:".
'
# Cherche une option d'aide quelque part
for i in "$@"
do
    case "$i" in
    -h|--help)
        echo "$HELP"
        exit 0
        ;;
    esac
done

#### VARIABLES #########################################################
CONFIGPATH="$HOME/.config/blob"
SETTINGS=""
OBPATH="$HOME/.config/openbox"
CURSESSION="$CONFIGPATH/current"
CONFIGDIR=""
LISTMSG=""
CZEN=0
TZEN=0
NUMDIRS=0
CONKYCMD=""
COLS=0
### CONFIGS VARIABLES
EXITFILE="$HOME/.config/bl-exit/bl-exitrc"
TERMDIR="$HOME/.config/terminator"
TERMFILE="$TERMDIR/config"
FEHFILE="$HOME/.fehbg"
NITRODIR="$HOME/.config/nitrogen"
NITROFILE="$NITRODIR/bg-saved.cfg"
CONKYPATH="$HOME/.config/conky"
CONKYSESSION="$CONKYPATH/conky-sessionfile"
TINTSESSION="$HOME/.config/tint2/tint2-sessionfile"
GTK2=".gtkrc-2.0"
GTK2MINE=".gtkrc-2.0.mine"
GTK3="$HOME/.config/gtk-3.0"
GTK3x="$HOME/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-notifyd.xml"
LDMDIR="/etc/lightdm"
LDM="lightdm-gtk-greeter.conf"
DMENUDIR="$HOME/.config/dmenu"
DMENU="dmenu-bind.sh"
XFILE=".Xresources"
BASHFILE=".bashrc"
PICKOB="OB theme"
PICKGTK="GTK theme"
PICKCONKY="Conky"
PICKTINT="Tint2"
PICKBG="Background Wallpaper"
PICKDMENU="dmenu (Alt menu)"
PICKLDM="Lightdm Login theme"
PICKEXIT="Exit dialog theme"
PICKTERM="Terminator"
PICKX="X configs"
### END CONFIGS VARIABLES

### DIALOG VARIABLES
DIALOG="yad --center --undecorated --borders=20 --window-icon=distributor-logo-bunsenlabs"
DIALOGDEC="yad --center  --borders=20 --window-icon=distributor-logo-bunsenlabs"
TITLE="BLOB Configuration Manager"
T="--text="
OK="--button=OK:0"
CANCEL="--button=gtk-cancel:1"
EXIT="--button=gtk-quit:1"
CLOSE="--button=gtk-close:1"
TXTINTRO='<big><b>BunsenLabs
Openbox Configuration Manager</b></big>


<b>Sauvegarde ou Restaure configurations pour:</b>

    Openbox theme
    GTK theme
    Conkys
    Tint2
    Arrière Plan
    Alt Menu (dmenu)
    LightDM theme
    Exit dialog theme
    X configs (.bashrc, .Xresources)
    Terminator (if default term)
    + Screenshot'
### END DIALOG VARIABLES

### USER SETTINGS
IMGCMD="bl-image-viewer"    # application command to view screenshot
MENUMODIFIER="super+space"  # keybind for show root-menu
MOUSECMD="click 3"          # mouse r-click
KEYDOWN=13           # adjust this for where "Preferences" is in the menu
#### END VARIABLES #####################################################

### FUNCTIONS ##########################################################

function Intro(){
    local INTRO RET
    getSet
    #  Si blob / est vide, alors ne pas afficher l'option "View Saved" dans la boîte de dialogue d'introduction
    if (( NUMDIRS > 0 ));then
        INTRO=$($DIALOGDEC "$T$TXTINTRO" \
        --title="$TITLE" \
        --button="Save Settings:0" --button="View Saved:2" $CLOSE \
        --borders=30 \
        2>/dev/null )
    else
        INTRO=$($DIALOGDEC \
        --title="$TITLE" \
        "$T$TXTINTRO" \
        --button="Save Settings:0" --button="gtk-close:1" \
        --borders=30 \
        2>/dev/null )
    fi
    RET=$?
    case $RET in
        0)  setName
            saveSettings
            getScrot
            if [[ -d $CONFIGDIR-BKP ]];then
                rm -rf "$CONFIGDIR-BKP"
                echo -e "\n  Temporary $CONFIGDIR deleted\n"
            fi
            restoreSettings
            ;;
        1)  echo "CANCELLED..."
            exit 0
            ;;
        2)  getSet
            restoreSettings
            ;;
        *)  echo "RETURN ERROR" 2>&1
            ;;
    esac
}

function getSet(){      # Obtenir le nom de la configuration BLOB actuellement configurée
    NUMDIRS=0
    NUMDIRS=$(ls -l "$CONFIGPATH" | grep -c ^d) # Vérifier si des dirs présents
    if (( NUMDIRS == 0 ));then
        if [[ -f $CURSESSION ]];then
            rm "$CURSESSION"
        fi
    elif (( NUMDIRS > 0 )) && [[ -f $CURSESSION ]];then
        SET=$(cat "$CURSESSION")
    fi
}

function getActiveMonitorDimensions(){   # Définir la largeur et la hauteur de la boîte de dialogue Affichee
    declare -a dim=()
    dim=($(bl-xinerama-prop))
    W=$(( ${dim[0]} / 3 ))
    H=$(( ${dim[1]} / 3 * 2 ))
    [[ $W =~ ^[0-9]+$ ]] && [[ $H =~ ^[0-9]+$ ]] || {
        print 'Error in getActiveMonitorDimensions'
        exit 1
    }
}

function setName(){  # set name of collection, make dir and session settings file
    MSG="  Les configurations seront enregistrées dans un nouveau répertoire dans  \
    \n  $CONFIGPATH\n\n  Entrez le nom de la nouvelle collection...  "
    MSG2="  Aucun fichier spécifié pour la nouvelle session enregistrée.\n\n  Essayer à nouveau?"
    LOOP=1
    DEL=0
    while [[ $LOOP ]];do  # Boucle si rien n'est sélectionné
        ANS=$($DIALOG --entry \
            $CANCEL --button="OK:0" \
            "$T$MSG" \
            2>/dev/null )
        if (( $? == 1 )) ;then # Annuler a été sélectionné
            Intro
        elif [[ ! $ANS ]] ;then     # L'entrée était vide
            $DIALOG --image="dialog-question" \
            "$CANCEL" "$OK" \
            "$T$MSG2" \
            2>/dev/null
            RET=$?
            echo -e "\n  Aucun nom entré pour la nouvelle collection!" 2>&1
            if (( RET == 0 ));then
                continue
            else
                Intro
            fi
        else
            ANS=$(echo $ANS | sed -e 's/ /_/g')    # Remplacer tous les espaces dans le nom du rep
            CONFIGDIR="$CONFIGPATH/$ANS"
            if [[ -d $CONFIGDIR ]];then
                echo -e "\n  $CONFIGDIR already exists"

                $DIALOG --form --image="dialog-question" \
                --text="Ecraser la session enregistrée existante?" \
                "$CANCEL" "$OK" \
                --width=300 \
                2>/dev/null

                if (( $? == 0 ));then
                    mv "$CONFIGDIR" "$CONFIGDIR-BKP" && mkdir -p "$CONFIGDIR"
                    DEL=1
                    SETTINGS="$CONFIGDIR/settings.cfg"
                    > "$SETTINGS"
                    LISTMSG="$CONFIGDIR/LISTMSG.txt"
                    > "$LISTMSG"
                    break
                else
                    continue
                fi
            fi
            mkdir -p "$CONFIGDIR"
            SETTINGS="$CONFIGDIR/settings.cfg"
            LISTMSG="$CONFIGDIR/LISTMSG.txt"
            > "$SETTINGS"
            > "$LISTMSG"
            break
        fi
    done
    setText
}

function setText(){
    TIME=$(date)
    if (( DEL == 1 ));then
        TXT="  (La session existante écrasée)"
    else
        TXT=""
    fi
    echo -e "\n  La configuration sera sauvegardée: $ANS$TXT"
    if [[ $1 = repeat ]];then
        > "$LISTMSG"    # reset LISTMSG.txt
    fi
    # Store list in listfile
    echo -e "<b>Nom de la configuration: $ANS</b>\t$TXT\nSaved at $TIME\n" >> "$LISTMSG"
}

function getBg(){    # Trouver si feh ou nitrogen a été utilisé. Enregistrer le(s) fichier(s) de configuration
    if [[ -e $NITROFILE ]] && [[ -e $FEHFILE ]];then  # Voir la dernière qui a été utilisée pour définir l'arrière-plan
        if [[ $NITROFILE -nt $FEHFILE ]];then # Utiliser la méthode la plus récente
            BGSET="NITROGEN"
        else
            BGSET="FEH"
        fi
    elif [[ -e $FEHFILE ]] && [[ ! -e $NITROFILE ]];then  # use feh for background
        BGSET="FEH"
    elif [[ -e $NITROFILE ]] &&  [[ ! -e $FEHFILE ]];then    # use nitrogen for background
        BGSET="NITROGEN"
    else
        echo -e "\n  Aucune application fond écran trouvée" 2>&1
        BGSET="None"
    fi
    echo -e "\n  Fond d'écran définit avec $BGSET"
    case "$BGSET" in
        FEH     )   echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    cp "$FEHFILE" "$CONFIGDIR"
                    echo -e "\n  $FEHFILE copied"
                    bgFeh
                    ;;
        NITROGEN)   echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    cp "$NITRODIR/nitrogen.cfg" "$CONFIGDIR"
                    cp "$NITROFILE" "$CONFIGDIR"
                    echo -e "\n  Sauvegarde du fichier Nitrogen : $NITROFILE"
                    getNitrogen
                    ;;
        None    )   echo -e "\n  Pas d'application Fond Ecran trouvée" 2>&1
                    echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    ;;
        *       )   echo -e "\n  ERREUR: Pas de configuration Fond Ecran trouvée" 2>&1
                    exit 1
                    ;;
    esac
}

function bgFeh(){    # Obtenir Feh fonds enregistrés
    FFILE="$CONFIGDIR/.fehbg"
    if [[ -f $FFILE ]];then
        BG=""
        # Obtenir des champs entre guillemets simples
        for F in $(grep -o "'.*'" $FFILE | sed "s/'//g" 2>/dev/null);do
            BG="$BG$F;\n\t"
        done
        echo -e "\n  Fond Ecran selectionné avec Feh, using:\n\
        \t$FEHFILE\n\t$BG"
        echo "Fond Ecran selectionné avec Feh:\n\t$BG" >> "$LISTMSG"
    else
        echo -e "\n  $FFILE pas trouvé" 2>&1
    fi
}

function getNitrogen(){  # get Nitrogen saved backgrounds
    NFILE="$CONFIGDIR/bg-saved.cfg"
    if [[ -f $NFILE ]];then
        BG=""
        while read line;do
            BGLINE=$(echo $line | awk -F"file=" '{print $2}')
            if [[ $BGLINE ]];then
                BG="$BG$BGLINE;\n"
            fi
        done < "$NFILE"
        echo -e "\n  Fond Ecran selectionné avec Nitrogen, using:\t$NITROFILE"
        echo -e "$BG"
        echo "Fond Ecran selectionné avec:\n$BG" >> "$LISTMSG"
    else
        echo -e "\n  $NFILE pas trouvé" 2>&1
    fi
}

function getConky(){
    CONKYCMD=""
    LISTMSGTXT=""
    TXT=""
    CONKYTEMP=$(mktemp --tmpdir blob.XXXX)
    if [[ $(pidof conky) ]];then    # Obtenir toutes les commandes conkys actifs
        > "$CONKYTEMP"
        pgrep -a conky | while read pid CMD;do
            echo "$CMD;" >> "$CONKYTEMP"
        done
        TXT="Conkys:\n\n"
        DEF="Default"
        MSG="Running Conkys:"
        while read line;do
            LINE=$(echo "$line" | sed 's/;//')
            CONKYCMD="$CONKYCMD $LINE & sleep 1s;"
            if [[ $LINE = "conky" ]] || [[ $LINE = "conky -q" ]];then
                line="$DEF"
            else
                line=${line##*" "}      # get full filepath
            fi
            TXT="$TXT$line"
            LISTMSGTXT="$LISTMSGTXT\n\t$line"
        done < "$CONKYTEMP"
        echo "[CONKY] $CONKYCMD" >> "$SETTINGS"
        rm -f "$CONKYTEMP"
        echo "$MSG\t$LISTMSGTXT\n" >> "$LISTMSG"
        echo -e "\n  Saved running Conky(s)"
    else
        DLG=$($DIALOG --form --image="dialog-warning" \
        --text="Vous avez choisi de sauver Conkys\nbut aucun n'est actif" \
        "$OK" \
        --width=300) 2>/dev/null
    fi
}

function checkConkyzen(){    # Voir si bl-conkyzen et fichier de session présent
    if type bl-conkyzen &>/dev/null;then
        if [[ -f $CONKYSESSION ]]; then
            CZEN=1  # Set flag pour le choix de restauration
        fi
    fi
}

function getTint(){
    TEMPTINT=$(mktemp --tmpdir blob.XXXX) # make blank tempfile, to save running tint2 paths
    if [[ $(pidof tint2) ]];then
        pgrep -a tint2 | while read pid cmd;do
            if [[ ${cmd%% *} = tint2 ]];then
                TPATH=$(echo "$cmd" | awk '{print $NF}')
                echo "$TPATH;" >> "$TEMPTINT"
            fi
        done
        TXT="Tint2s:\n\n"
        MSG="Running Tint2s:"
        TINTCMD=""
        LISTMSGTXT=""
        while read line;do
            TXT="$TXT$line"
            LINE=$(echo "$line" | sed 's/;//')
            if [[ $LINE = tint2 ]];then         # default command was used
                TINTCMD="$TINTCMD$LINE;"
                LISTMSGTXT="$LISTMSGTXT\n\tDefault Tint2"
            else
                TINTCMD="$TINTCMD$LINE;"
                LISTMSGTXT="$LISTMSGTXT\n\t$LINE"
            fi
        done < "$TEMPTINT"
        echo "[TINT2] $TINTCMD" >> "$SETTINGS"
        rm -f "$TEMPTINT"
        echo "$MSG\t$LISTMSGTXT\n" >> "$LISTMSG"
        echo -e "\n  Saved running Tint2(s)"
    else
        DLG=$($DIALOG --form --image="dialog-warning" \
        --text="Vous avez choisi de sauver Tint2\nbut aucun n'est actif" \
        "$OK" \
        --width=300) 2>/dev/null
    fi
}

function killTints(){
    pgrep -a tint2 | while read pid cmd; do
        if [[ ${cmd%% *} = tint2 ]]; then
            kill "$pid"
        fi
    done
}

function checkTint2zen(){    # see if bl-tint2zen and session file present
    if type bl-tint2zen &>/dev/null;then
        if [[ -f $TINTSESSION ]]; then
            TZEN=1          # set flag for Restore choice
        fi
    fi
}

function getOBtheme(){   # copy <theme> section from rc.xml to obtheme.txt
    RCFILE="$OBPATH/rc.xml"
    tag="theme"
    sed -n "/<$tag>/,/<\/$tag>/p" "$RCFILE" > "$CONFIGDIR/obtheme.txt"
    echo "[OBTHEME]" >> "$SETTINGS"
    getOBname
}

function getOBname(){    # get OB theme name
    OBFILE="$CONFIGDIR/obtheme.txt"
    OBTHEME=$(awk 'NR==2 {print;exit}' $OBFILE | awk -F'[>|<]' '{print $3}')
    TXT="Openbox theme:  $OBTHEME\n"
    echo -e "\n  Enregistré $TXT"
    echo "$TXT" >> "$LISTMSG"
}

function getGTKtheme(){
    GTKTHEMES=( "$HOME/$GTK2" "$HOME/$GTK2MINE" "$GTK3" "$GTK3x" )
    for f in "${GTKTHEMES[@]}";do
        if [[ -f $f ]];then
            cp "$f" "$CONFIGDIR"
        elif [[ -d $f ]];then
            cp -r "$f" "$CONFIGDIR"
        fi
    done
    echo "[GTK]" >> "$SETTINGS"
    getGTKname
}

function getGTKname(){   # get GTK theme name
    GTKFILE="$CONFIGDIR/.gtkrc-2.0"
    while read line;do
        if [[ $(echo $line | grep "gtk-theme-name" ) ]] &>/dev/null;then
            GTKTHEME=$(echo $line | awk -F '"' '{print $2}')
        fi
    done < "$GTKFILE"
    TXT="GTK theme:  $GTKTHEME\n"
    echo -e "\n  Enregistré $TXT"
    echo "$TXT" >> "$LISTMSG"
}

function getDmenu(){
    if [[ -d $DMENUDIR ]];then
        cp "$DMENUDIR/$DMENU" "$CONFIGDIR"
        echo "[DMENU]" >> "$SETTINGS"
        TXT="dmenu config:  $DMENUDIR/$DMENU\n"
        echo -e "\n  Enregistré $TXT"
        echo "$TXT" >> "$LISTMSG"
    else
        echo "  $DMENUDIR/$DMENU pas trouvé"
    fi
}

function getLightdm(){
    if [[ -f $LDMDIR/$LDM ]];then
        cp "$LDMDIR/$LDM" "$CONFIGDIR"
        TXT="Lightdm config:  $LDMDIR/$LDM\n"
        echo -e "\n  Enregistré $TXT"
        echo "[LIGHTDM]" >> "$SETTINGS"
        echo "$TXT" >> "$LISTMSG"
    fi
}

function getTerminator(){
    if [[ -e $TERMFILE ]];then
        cp "$TERMFILE" "$CONFIGDIR"
        TXT="Terminator config:  $TERMFILE\n"
        echo -e "\n  Enregistré $TXT"
        echo "[TERMINATOR]" >> "$SETTINGS"
        echo "$TXT" >> "$LISTMSG"
    fi
}

function getXconfig(){
    XFILE="$HOME/.Xresources"
    BASHFILE="$HOME/.bashrc"
    if [[ -f $XFILE ]];then
        cp "$XFILE" "$CONFIGDIR"
    fi
    if [[ -f $BASHFILE ]];then
        cp "$BASHFILE" "$CONFIGDIR"
    fi
    TXT="X terminal config:  $BASHFILE;$XFILE\n"
    echo -e "\n  Enregistré $TXT"
    echo "[XFILES]" >> "$SETTINGS"
    echo "$TXT" >> "$LISTMSG"
}

function getBLexitrc(){
    if [[ -f $EXITFILE ]];then
        cp "$EXITFILE" "$CONFIGDIR"
        echo "[EXITRC]" >> "$SETTINGS"
        TXT="bl-exitrc config:  $EXITFILE\n"
        echo -e "\n  Enregistré $TXT"
        echo "$TXT" >> "$LISTMSG"
    else
        echo "  $EXITFILE pas trouvé"
    fi
}

function checkTint2(){   # kill or restart tint2s for screenshot, if necessary
    if [[ $1 = stop ]];then
        if ! cat "$SETTINGS" | grep "TINT2" &>/dev/null;then
            tmpTINT=$(mktemp --tmpdir blob.XXXX) # make blank tempfile, to save running tint2 paths
            if [[ $(pidof tint2) ]];then
                pgrep -a tint2 | while read pid cmd;do
                    if [[ ${cmd%% *} = tint2 ]];then
                        echo $cmd >> "$tmpTINT"
                    fi
                done
            fi
            killTints
        fi
    fi
    if [[ $1 = start ]];then
        if [[ -f "$tmpTINT" ]] 2>/dev/null;then
            while read line;do
                ($line &) &>/dev/null
                sleep 1s
            done < "$tmpTINT"
            rm -f "$tmpTINT"
        fi
    fi
}

function getScrot(){
    pid=""
    TMPSCROT=$(mktemp --tmpdir blob.XXXX)
    SCROT="$CONFIGPATH/$ANS"
    CURRDTOP=$(xprop -root _NET_CURRENT_DESKTOP | tail -c -2) # desktop number
    MONS=$(xrandr -q | grep -c " connected")    # number of monitors
    # Set mouse position, for appearance of root-menu
    screenW=$(xrandr -q | awk '/Screen/ {print $8}')
    screenH=$(xrandr -q | awk '/Screen/ {print $10}')
    screenH=${screenH%,}

    if (( MONS == 1 ));then # single monitor
        appX=$(( (screenW/20)*8 ))
        menuX=$(( (screenW/20)*2 ))
    else
        appX=$(( (screenW/20)*4 ))
        menuX=$(( (screenW/20)*1 ))
    fi
    appY=$(( (screenH/20)*4 ))
    menuY=$(( (screenH/20)*4 ))

    wmctrl -l -x > "$TMPSCROT"      # store window list in tempfile
    wmctrl -k on                    # hide windows, show desktop
    # show any conkys which have been hidden by wmctrl, (ie not own_window_type desktop);
    # unless Conkys weren't selected to be saved
    if cat "$SETTINGS" | grep "CONKY" &>/dev/null;then
        for CONK in $(xdotool search --classname "Conky");do
            xdotool windowactivate "$CONK" 2>/dev/null
        done
    fi
    checkTint2 stop     # stop running Tint2s for the scrot,
                        # if not selected to be saved
    # start lxappearance
    lxappearance &
    pid=$!
    sleep 0.5
    # get lx window, make sure it loses focus, then move mouse and start root-menu
    LX=$(xdotool getwindowfocus)
    xdotool windowmove --sync $LX $appX $appY && sleep 0.1 && \
    xdotool mousemove --sync --window $LX -- -50 0 && xdotool click 1
    xdotool mousemove --sync $menuX $menuY && xdotool key --clearmodifiers $MENUMODIFIER

    i=1
    while (( i <= KEYDOWN ));do
        xdotool key --delay 50 Down
        i=$(( i+1 ))
    done
    xdotool key --delay 20 Right && sleep 0.3

    # take scrot
    scrot -t 9 "$SCROT.jpg"    # scrot thumbnail @9% fullsize
    THUMB=$(find "$CONFIGPATH" -maxdepth 1 -type f -name "*-thumb.jpg" 2>/dev/null)
    mv "$THUMB" "$CONFIGDIR"

    # close root menu
    xdotool mousemove_relative --sync --polar 0 10 $MOUSECMD
    # kill lxappearance
    if [[ $(pgrep lxappearance | grep $pid) ]];then
        kill -9 $pid &>/dev/null
    fi

    # restore hidden windows
    while read line; do
        WINDOW=$(echo $line | awk '{print $1}') # Window_ID is first field
        DTOP=$(echo $line | awk '{print $2}' )  # Desktop number is second field
        if (( DTOP == CURRDTOP )) &>/dev/null;then
            xdotool windowactivate "$WINDOW"
        fi
    done < "$TMPSCROT"
    # restore any hidden Conkys
    for CONK in $(xdotool search --classname "Conky");do
        xdotool windowactivate "$CONK" 2>/dev/null
    done
    checkTint2 start        # restore any stopped Tint2s
    rm -f "$TMPSCROT"
}

function restoreGTK(){   # $1 is chosen saved config dir
    GTKPATHS=( "$HOME" "$HOME" "$GTK3" "$GTK3x" )
    GTKSAVED=( "$1/$GTK2" "$1/$GTK2MINE" "$1/gtk-3.0" "$1/xfce4-notifyd.xml" )
    i=0
    for f in ${GTKSAVED[@]};do
        if [[ -e $f ]];then     # if destination exists
            if [[ -e ${GTKPATHS[i]} ]];then
                if [[ ${GTKSAVED[i]} = $1/gtk-3.0 ]];then
                    cp -r ${GTKSAVED[i]}/* ${GTKPATHS[i]} # restore contents of gtk-3.0
                fi
                cp ${GTKSAVED[i]} ${GTKPATHS[i]}
                echo -e "\n  Restauré: ${GTKSAVED[i]}"
            else
                echo -e "\n  Restauration path ${GTKPATHS[i]} pas trouvé" 2>&1
            fi
        else
            echo -e "\n  ${GTKSAVED[i]} pas trouvé" 2>&1
        fi
        i=$((i+1))
    done
}

function restoreOBrc(){
    RCFILE="$OBPATH/rc.xml"
    THEMEFILE="$1/obtheme.txt"
    FTEMP=$(mktemp --tmpdir blob.XXXX)
    if [[ $(grep "[OBTHEME]" "$1/settings.cfg" ) ]] &>/dev/null;then
        # backup rc.xml first
        NOW=$(date +"%Y%m%d-%H%M%S")
        RCBKP="$RCFILE.blob.$NOW"
        cp "$RCFILE" "$RCBKP"
        # remove older backups
        for f in $(find "$OBPATH" -type f|grep .blob. );do
            if [[ $f -ot $RCBKP ]];then
                rm "$f"
            fi
        done
        ## put placeholder in place of <theme> section, write to tempfile
        sed -n "/<theme>/{:a;N;/<\/theme>/!ba;N;s/.*\n/THEMESECTION\n/};p" "$RCFILE" > "$FTEMP"
        # replace placeholder from theme file
        sed -i "/THEMESECTION/{
            s/THEMESECTION//g
            r $THEMEFILE
        }" "$FTEMP"
        sed -i '/^$/d' "$FTEMP"   # remove empty lines
        cp "$FTEMP" "$RCFILE"     # overwrite rc.xml
        echo -e "\n  rc.xml Sauvegardé et modifié pour OB thème"
        rm -f "$FTEMP"
    fi
}

function restoreTint2(){      # write to tint2 session file
    echo "$1" | awk -F';' '{for(i=1; i<=NF; i++) print $i}' >> "$TINTSESSION"
    killTints
    while read tintline;do
        (tint2 -c "$tintline" &) &>/dev/null
        sleep 1s
    done < "$TINTSESSION"
}

function restoreDmenu(){
    DFILE="$1"
    if [[ -e $DMENUDIR ]];then        # backup DMENU first
        DMENUBKP="$DMENUDIR/$DMENU.bkp"
        cp "$DMENUDIR/$DMENU" "$DMENUBKP"
        cp "$DFILE" "$DMENUDIR"
        echo -e "\n  $DMENUDIR/$DMENU backed up and restored"
    else
        cp "$DFILE" "$DMENUDIR/$DMENU"
        echo -e "\n  $DMENUDIR/$DMENU restored"
    fi
}

function restoreBLexitrc(){
    EFILE="$1"
    if [[ -e $EXITFILE ]];then        # backup bl-exitrc first
        EFILEBKP="$EFILE.bkp"
        cp "$EFILE" "$EFILEBKP"
        cp "$EFILE" "$EXITFILE"
        echo -e "\n  $EXITFILE backed up and restored"
    else
        cp "$EFILE" "$EXITFILE"
        echo -e "\n  $EXITFILE restored"
    fi
}

function restoreLightdm(){   # need sudo to restore lightdm-gtk-greeter.conf
    CMD="cp $1 $LDMDIR/$LDM"
    TXT="Authentifier la restauration de lightdm-gtk-greeter.conf"
    LOOP=1
    while [[ $LOOP ]];do
        gksudo -m "$TXT" "$CMD"
        DLG=$?
        case "$DLG" in
            0   )   MSG="  Restauré: lightdm-gtk-greeter.conf"
                    echo -e "\n  $MSG"
                    break
                    ;;
            255 )   MSG="  Authentification annulée\n\nlightdm-gtk-greeter.conf n'a pas été restauré"
                    echo -e "\n  $MSG" 2>&1
                    break
                    ;;
            *   )   MSG="  Échec de l'entrée du mot de passe\n\nlightdm-gtk-greeter.conf n'a pas été restauré"
                    echo -e "\n  $MSG" 2>&1
                    "$DIALOG" --image="dialog-warning" "$T$MSG" "$OK" 2>/dev/null
                    ;;
        esac
    done
}

function restoreXsettings(){
    XBKP=""
    for var in "$@";do
        if [[ -e $var ]];then        # backup .bashrc & .Xresources first
            XBKP="$var.bkp"
            cp "$var" "$XBKP"
            cp "$var" "$HOME"
            echo -e "\n  $var Sauvegardé et restauré"
        else
            cp "$var" "$HOME"
            echo -e "\n  $var restauré"
        fi
    done
}

function restoreTerminator(){
    TFILE="$1"
    if [[ -e $TERMDIR ]];then        # backup terminator/config first
        TERMBKP="$TERMDIR/config.bkp"
        cp "$TFILE" "$TERMBKP"
        cp "$TFILE" "$TERMDIR/config"
        echo -e "\n  $TERMDIR/config Sauvegardé et restauré"
    else
        cp "$TFILE" "$TERMDIR/config"
        echo -e "\n  $TERMDIR/config restauré"
    fi
}

function reloadGTK(){ # reload gtk theme after restoring saved config
python - <<END
import gtk

events=gtk.gdk.Event(gtk.gdk.CLIENT_EVENT)
data=gtk.gdk.atom_intern("_GTK_READ_RCFILES", False)
events.data_format=8
events.send_event=True
events.message_type=data
events.send_clientmessage_toall()

END
}

function cleanup(){
    if [[ $1 = all ]];then
        if [[ -d $CONFIGDIR ]];then
            rm -rf "$CONFIGDIR"
            echo -e "\n  Supprimé $CONFIGDIR"
        fi
        if [[ -d $CONFIGDIR-BKP ]];then
            mv "$CONFIGDIR-BKP" "$CONFIGDIR"
            echo -e "\n  Annulé\n..Temporary $CONFIGDIR Restauré\n"
        fi
        rm -f /tmp/blob.*
    elif [[ $1 = save ]];then
        saveSettings
    fi
}

function saveSettings(){
    SHOW=0
    if (( COLS == 0 ));then
        SELECT="FALSE"
    else
        SELECT="TRUE"
    fi
    COLUMNS=(\
        $SELECT "$PICKOB" \
        $SELECT "$PICKGTK" \
        $SELECT "$PICKCONKY" \
        $SELECT "$PICKTINT" \
        $SELECT "$PICKBG" \
        $SELECT "$PICKDMENU" \
        $SELECT "$PICKLDM" \
        $SELECT "$PICKEXIT" \
        $SELECT "$PICKX" \
        )
    # add terminator to array if set as default
    if  readlink -f /usr/bin/x-terminal-emulator | grep terminator &>/dev/null;then
        COLUMNS=("${COLUMNS[@]}" $SELECT "$PICKTERM")
    fi

    SLOOP=1
    while (( SLOOP == 1 ));do
        CHOICE=$($DIALOGDEC --list --checklist \
            --title="Choisissez les configurations à enregistrer..." \
            --button="Sélectionner All:2" \
            $CANCEL $OK \
            --height=340 \
            --column="Select" --column="Config" "${COLUMNS[@]}" \
            2>/dev/null )
            ret=$?
        if (( ret == 1 )); then # cancel button pressed
            COLS=0
            cleanup all
            restoreSettings
        elif (( ret == 2 ));then
            COLS=1
            saveSettings
            SHOW=1
        else
            if [[ ! $CHOICE ]] ; then # entry field is empty, so try again
                RET=$($DIALOG  --image="dialog-question" \
                --text="\n  Choisissez...." \
                $EXIT $OK \
                --width=300 \
                2>/dev/null )
                if (( $? == 1 ));then
                    cleanup all
                fi
            else
                i=0
                retChoice=()
                OIFS=$IFS # save Internal Field Separator
                IFS=$"|" # separator is "|" in returned choices
                # dialog return is in format 'TRUE|value|\nTRUE|value'
                for ret in $CHOICE; do
                    if [[ $(echo $ret | grep TRUE) ]] &>/dev/null;then
                        continue
                    fi
                    retChoice[$i]="$ret"
                    i=$((i+1))
                done
                IFS=$OIFS # reset IFS back to default
                len=${#retChoice[@]}
                for (( i=0; i<${len}; i++ ));do
                    item="${retChoice[$i-1]}"
                    case "$item" in
                        "$PICKOB"   )   getOBtheme
                                        ;;
                        "$PICKGTK"  )   getGTKtheme
                                        ;;
                        "$PICKCONKY")   getConky
                                        ;;
                        "$PICKTINT" )   getTint
                                        ;;
                        "$PICKBG"   )   getBg
                                        ;;
                        "$PICKDMENU")   getDmenu
                                        ;;
                        "$PICKLDM"  )   getLightdm
                                        ;;
                        "$PICKEXIT" )   getBLexitrc
                                        ;;
                        "$PICKTERM" )   getTerminator
                                        ;;
                        "$PICKX"    )   getXconfig
                                        ;;
                        *           )   echo -e "\n  Valeur Inconnue!" 2>&1
                                        exit 1
                                        ;;
                    esac
                done
                SLOOP=0
            fi
        fi
    done
    if (( SHOW == 0 ));then
        COLS=0      # reset columns unselected
        TXT="<big><b><u>Openbox Configurations à sauvegarder:</u></b></big>\n\n"
        TXT2=$(cat "$LISTMSG")
        NEW=$($DIALOG --text="$TXT$TXT2") 2>/dev/null
        ret=$?
        if (( ret == 1 ));then
            cleanup all
            restoreSettings
        else
            echo "$ANS" > "$CURSESSION"     # replace entry in saved config flag file
        fi
    fi
}

function ViewRestoreDialog(){  #   Display saved theme collections
    getSet          # get name of latest set BLOB config
    if (( NUMDIRS == 0 ));then   # no saved configs; go back to Intro dialog
        Intro
    fi
    DLGLIST=""
    setARR=()
    namesARR=()
    thumbsARR=()
    i=0
    for dir in "$CONFIGPATH"/* ;do
        if [[ -d $dir ]];then
            if [[ -e $dir/settings.cfg ]];then
                d=$(echo $dir | sed -e 's/ /_/g')    # replace any spaces in dir name
                namesARR[$i]="<big>$(basename $d)</big>" # add theme collection name to array
                d=${d##*/}  # get directory name
                # Get name of current session, set icon for TRUE/FALSE
                if [[ $SET = $d ]];then
                    setARR[$i]="gtk-yes"
                else
                    setARR[$i]="gtk-no"
                fi
                IMGTHUMB="None"     # Placeholder if no thumbnail found
                f="$dir"/*"-thumb.jpg"
                if [[ $f ]];then
                    IMGTHUMB="$f"
                fi
                thumbsARR[$i]="$IMGTHUMB"
                CONFIGS="\""
                while read line;do
                    CONFIGS="$CONFIGS $line\n"
                done < "$dir/LISTMSG.txt"
                CONFIGS="$CONFIGS\""
                configARR[$i]="$CONFIGS" # add saved configs to array
            fi
            i=$((i+1))
        fi
    done
    for ((j=0; j<${#namesARR[*]}; j++));do
        DLGLIST="$DLGLIST ${setARR[j]} ${namesARR[j]} ${thumbsARR[j]}"
    done
}

function restoreSettings(){
    ViewRestoreDialog
    FPATH=""
    LOOP=1
    while [[ $LOOP ]] ;do
        CONFIG=$($DIALOGDEC --list --title="$TITLE" \
            --text="Double-click selection, or \"Enter\", ou utiliser \"Restore\" Pour restaurer les paramètres\n" \
            --separator=" " \
            --button="About:5" \
            --button="View image:4" --button="Add New:3" \
            --button="Delete:2" --button="Restore:0" --button="gtk-quit:1" \
            --always-print-result \
            --width=$W --height=$H --center --image-preview \
            --expand-column=3 \
            --column="Last Set:IMG" \
            --column="Config Name":TEXT \
            --column="Screenshot":IMG \
            $DLGLIST \
            2>/dev/null )
        RET=$?
        if [[ $CONFIG ]];then
            DIR=$(echo "$CONFIG" | awk -F'[>|<]' '{print $3}' )
            FPATH="$CONFIGPATH/$DIR"
        fi
        case $RET in
            0)  SAVED="$FPATH/LISTMSG.txt"
                TEXT="Restauration des configurations enregistrées comme <big>$DIR</big>\n\n"
                TEXT="$TEXT$(cat $SAVED)"
                $DIALOG "$T$TEXT" "$CANCEL" "$OK" 2>/dev/null
                if (( $? == 0 ));then
                    echo $(basename $FPATH) > "$CURSESSION"
                    break
                fi
                ;;
            1)  exit 0
                ;;
            2)  if [[ ! $CONFIG ]];then
                    $DIALOG --text="Faites une sélection avant d'essayer de supprimer" "$EXIT" "$OK" 2>/dev/null
                    if (( $? == 0 ));then
                        continue
                    else
                        exit 0
                    fi
                fi
                TEXT="Supprimer les configurations enregistrées <b>$FPATH</b>\nand screenshot?"
                $DIALOG "$T$TEXT" "$CANCEL" "$OK" 2>/dev/null

                if (( $? == 0 ));then
                    rm -rf "$FPATH"
                    rm "$FPATH.jpg"
                    echo -e "\n$DIR DELETED"
                    currentsession=$(cat $CURSESSION)
                    fpath=$(basename $FPATH)
                    if [[ $currentsession = $fpath ]];then
                        echo "" > "$CURSESSION"
                    fi
                    restoreSettings
                else
                    continue
                fi
                ;;
            3)  setName
                saveSettings
                getScrot
                $DIALOG --text="Les paramètres ont été enregistrés <b>$ANS</b>" --image="gtk-save" "$OK" 2>/dev/null
                if [[ -d $CONFIGDIR-BKP ]];then
                    rm -rf "$CONFIGDIR-BKP"
                    echo -e "\n  Temporary $CONFIGDIR deleted\n"
                fi
                restoreSettings
                ;;
            4)  # show screenshot in image viewer
                SEL=$(echo "$CONFIG" | awk -F'[>|<]' '{print $3}' )
                if [[ $SEL ]];then
                    img="$CONFIGPATH/$SEL.jpg"
                    $IMGCMD "$img"
                else
                    $DIALOG --text="Choisissez" 2>/dev/null
                fi
                restoreSettings
                ;;
            5)  Intro
                ;;
            *)  if (( RET == 252 ));then
                    echo -e "\n  Sortie avec \"ESC\" key"
                else
                    echo -e "\n  Erreur= $RET" 2>&1
                fi
                exit 1
                ;;
        esac
    done
    SETCFG="$FPATH/settings.cfg"
    # Get chosen saved configs and restore them
    # kill conkys and tint2s, in case saved config doesn't include them
    if [[ $(pidof conky) ]];then
        killall conky
    fi
    if [[ $(pidof tint2) ]];then
        killall tint2
    fi
    while read line;do
        TAG=$(echo $line | awk '{print $1}')
        VAL=$(echo $line | awk '{print $2}')
        case "$TAG" in
            "[TINT2]"       )   checkTint2zen # see if bl-tint2zen installed
                                if (( TZEN == 1 ));then
                                    > "$TINTSESSION" # overwrite tint2 session file
                                fi
                                TINTCMD=$(echo $line | cut -d ' ' -f2-)
                                restoreTint2 "$TINTCMD"
                                ;;
            "[CONKY]"       )   checkConkyzen # see if bl-conkyzen installed
                                if (( CZEN == 1 ));then
                                    > "$CONKYSESSION" # overwrite conky session file
                                fi
                                CONKYCMD=$(echo $line | cut -d ' ' -f2-)
                                # write to conky session file...
                                echo $CONKYCMD | awk -F';' '{for(i=1; i<=NF; i++) print $i}' >> "$CONKYSESSION"
                                killall conky
                                source "$CONKYSESSION"
                                ;;
            "[GTK]"         )   restoreGTK "$FPATH"
                                reloadGTK
                                ;;
            "[OBTHEME]"     )   restoreOBrc "$FPATH"
                                ;;
            "[BACKGROUND]"  )   if [[ $VAL = FEH ]];then
                                    cp "$FPATH/.fehbg" "$HOME"
                                    source "$HOME/.fehbg"
                                else
                                    cp "$FPATH/bg-saved.cfg" "$NITRODIR"
                                    nitrogen --restore
                                fi
                                ;;
            "[DMENU]"       )   restoreDmenu "$FPATH/$DMENU"
                                ;;
            "[LIGHTDM]"     )   restoreLightdm "$FPATH/$LDM"
                                ;;
            "[EXITRC]"      )   restoreBLexitrc "$FPATH/bl-exitrc"
                                ;;
            "[XFILES]"      )   restoreXsettings "$FPATH/.bashrc" "$FPATH/.Xresources"
                                ;;
            "[TERMINATOR]"  )   restoreTerminator "$FPATH/config"
                                ;;
            *               )   echo -e "  Valeur inconnue!" 2>&1
                                restoreSettings
                                ;;
        esac
    done < "$SETCFG"
    openbox --reconfigure
    restoreSettings
}

### END FUNCTIONS ######################################################
# test for blobthemes config directory, create if it doesn't exist
mkdir -p "$CONFIGPATH"
# create file to hold most recent saved configuration name
if [[ ! -f $CURSESSION ]] &>/dev/null;then
    touch "$CURSESSION"
fi
getActiveMonitorDimensions
getSet
if (( NUMDIRS == 0 ));then
    Intro
else
    restoreSettings
fi
exit 0
